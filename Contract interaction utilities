// contractUtils.js - Utility functions untuk interaksi dengan smart contract

import { ethers } from 'ethers';
import { toast } from 'react-toastify';

// ===========================================
// CONFIGURATION
// ===========================================

export const BSC_TESTNET_CONFIG = {
  chainId: '0x61',
  chainName: 'BSC Testnet',
  nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
  rpcUrls: ['https://data-seed-prebsc-1-s1.binance.org:8545'],
  blockExplorerUrls: ['https://testnet.bscscan.com']
};

export const BSC_MAINNET_CONFIG = {
  chainId: '0x38',
  chainName: 'BSC Mainnet',
  nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
  rpcUrls: ['https://bsc-dataseed.binance.org/'],
  blockExplorerUrls: ['https://bscscan.com']
};

// Ganti dengan address contract yang sudah di-deploy
export const CONTRACTS = {
  ASSET_NFT: "0xYourAssetNFTContractAddress",
  MARKETPLACE: "0xYourMarketplaceContractAddress"
};

// ===========================================
// WALLET CONNECTION
// ===========================================

export const connectWallet = async () => {
  if (typeof window.ethereum === 'undefined') {
    toast.error('âŒ MetaMask tidak terdeteksi! Silakan install MetaMask.');
    return null;
  }

  try {
    const accounts = await window.ethereum.request({ 
      method: 'eth_requestAccounts' 
    });
    
    toast.success(`âœ… Wallet terhubung: ${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`);
    return accounts[0];
  } catch (error) {
    console.error('Error connecting wallet:', error);
    toast.error('âŒ Gagal menghubungkan wallet');
    return null;
  }
};

export const switchToBSC = async (isTestnet = true) => {
  const config = isTestnet ? BSC_TESTNET_CONFIG : BSC_MAINNET_CONFIG;
  
  try {
    await window.ethereum.request({
      method: 'wallet_switchEthereumChain',
      params: [{ chainId: config.chainId }]
    });
    toast.success('âœ… Berhasil switch ke BSC');
  } catch (error) {
    if (error.code === 4902) {
      try {
        await window.ethereum.request({
          method: 'wallet_addEthereumChain',
          params: [config]
        });
        toast.success('âœ… BSC berhasil ditambahkan');
      } catch (addError) {
        toast.error('âŒ Gagal menambahkan network BSC');
      }
    } else {
      toast.error('âŒ Gagal switch network');
    }
  }
};

export const getProvider = () => {
  if (typeof window.ethereum !== 'undefined') {
    return new ethers.BrowserProvider(window.ethereum);
  }
  throw new Error('No Ethereum provider found');
};

export const getSigner = async () => {
  const provider = getProvider();
  return await provider.getSigner();
};

// ===========================================
// ASSET NFT FUNCTIONS
// ===========================================

export const createAsset = async (assetData) => {
  try {
    const signer = await getSigner();
    const contract = new ethers.Contract(
      CONTRACTS.ASSET_NFT,
      ASSET_NFT_ABI,
      signer
    );

    const tx = await contract.createAsset(
      assetData.name,
      assetData.description,
      assetData.location,
      assetData.assetType,
      ethers.parseEther(assetData.totalValue.toString()),
      assetData.imageURI,
      assetData.documentURI
    );

    toast.info('â³ Membuat aset... Tunggu konfirmasi blockchain');
    const receipt = await tx.wait();
    
    // Extract tokenId from event
    const event = receipt.logs.find(log => {
      try {
        return contract.interface.parseLog(log).name === 'AssetCreated';
      } catch (e) {
        return false;
      }
    });
    
    const tokenId = event ? contract.interface.parseLog(event).args.tokenId : null;
    
    toast.success(`âœ… Aset berhasil dibuat! Token ID: ${tokenId}`);
    return { success: true, tokenId, receipt };
  } catch (error) {
    console.error('Create asset error:', error);
    toast.error(`âŒ Gagal: ${error.reason || error.message}`);
    return { success: false, error };
  }
};

export const fractionalizeAsset = async (tokenId, totalFractions) => {
  try {
    const signer = await getSigner();
    const contract = new ethers.Contract(
      CONTRACTS.ASSET_NFT,
      ASSET_NFT_ABI,
      signer
    );

    const tx = await contract.fractionalizeAsset(tokenId, totalFractions);
    
    toast.info('â³ Memfraksionalisasi aset...');
    const receipt = await tx.wait();
    
    toast.success('âœ… Aset berhasil difraksionalisasi!');
    return { success: true, receipt };
  } catch (error) {
    console.error('Fractionalize error:', error);
    toast.error(`âŒ Gagal: ${error.reason || error.message}`);
    return { success: false, error };
  }
};

export const getAssetDetails = async (tokenId) => {
  try {
    const provider = getProvider();
    const contract = new ethers.Contract(
      CONTRACTS.ASSET_NFT,
      ASSET_NFT_ABI,
      provider
    );

    const asset = await contract.getAsset(tokenId);
    
    return {
      name: asset.name,
      description: asset.description,
      location: asset.location,
      assetType: asset.assetType,
      totalValue: ethers.formatEther(asset.totalValue),
      totalFractions: asset.totalFractions.toString(),
      fractionTokenAddress: asset.fractionTokenAddress,
      imageURI: asset.imageURI,
      documentURI: asset.documentURI,
      isActive: asset.isActive,
      createdAt: new Date(Number(asset.createdAt) * 1000)
    };
  } catch (error) {
    console.error('Get asset error:', error);
    return null;
  }
};

export const getAllAssets = async (maxTokenId = 100) => {
  const assets = [];
  
  for (let i = 0; i < maxTokenId; i++) {
    try {
      const asset = await getAssetDetails(i);
      if (asset && asset.isActive) {
        assets.push({ ...asset, tokenId: i });
      }
    } catch (error) {
      break; // Stop when no more assets
    }
  }
  
  return assets;
};

// ===========================================
// FRACTION TOKEN FUNCTIONS
// ===========================================

export const buyFractions = async (fractionTokenAddress, amount) => {
  try {
    const signer = await getSigner();
    const contract = new ethers.Contract(
      fractionTokenAddress,
      FRACTION_TOKEN_ABI,
      signer
    );

    const price = await contract.fractionPrice();
    const totalCost = (price * BigInt(amount)) / ethers.parseEther("1");
    
    const tx = await contract.buyFractions(amount, {
      value: totalCost
    });

    toast.info('â³ Membeli fraksi...');
    await tx.wait();
    
    toast.success(`âœ… Berhasil membeli ${amount} fraksi!`);
    return { success: true };
  } catch (error) {
    console.error('Buy fractions error:', error);
    toast.error(`âŒ Gagal: ${error.reason || error.message}`);
    return { success: false, error };
  }
};

export const sellFractions = async (fractionTokenAddress, amount) => {
  try {
    const signer = await getSigner();
    const contract = new ethers.Contract(
      fractionTokenAddress,
      FRACTION_TOKEN_ABI,
      signer
    );

    const tx = await contract.sellFractions(amount);

    toast.info('â³ Menjual fraksi...');
    await tx.wait();
    
    toast.success(`âœ… Berhasil menjual ${amount} fraksi!`);
    return { success: true };
  } catch (error) {
    console.error('Sell fractions error:', error);
    toast.error(`âŒ Gagal: ${error.reason || error.message}`);
    return { success: false, error };
  }
};

export const claimRevenue = async (fractionTokenAddress) => {
  try {
    const signer = await getSigner();
    const contract = new ethers.Contract(
      fractionTokenAddress,
      FRACTION_TOKEN_ABI,
      signer
    );

    const claimable = await contract.getClaimableRevenue(await signer.getAddress());
    
    if (claimable === 0n) {
      toast.info('â„¹ï¸ Tidak ada revenue yang bisa di-claim');
      return { success: false };
    }

    const tx = await contract.claimRevenue();

    toast.info('â³ Claiming revenue...');
    await tx.wait();
    
    const amount = ethers.formatEther(claimable);
    toast.success(`âœ… Berhasil claim ${amount} BNB!`);
    return { success: true, amount };
  } catch (error) {
    console.error('Claim revenue error:', error);
    toast.error(`âŒ Gagal: ${error.reason || error.message}`);
    return { success: false, error };
  }
};

export const getClaimableRevenue = async (fractionTokenAddress, userAddress) => {
  try {
    const provider = getProvider();
    const contract = new ethers.Contract(
      fractionTokenAddress,
      FRACTION_TOKEN_ABI,
      provider
    );

    const claimable = await contract.getClaimableRevenue(userAddress);
    return ethers.formatEther(claimable);
  } catch (error) {
    console.error('Get claimable revenue error:', error);
    return '0';
  }
};

export const getFractionBalance = async (fractionTokenAddress, userAddress) => {
  try {
    const provider = getProvider();
    const contract = new ethers.Contract(
      fractionTokenAddress,
      FRACTION_TOKEN_ABI,
      provider
    );

    const balance = await contract.balanceOf(userAddress);
    return ethers.formatEther(balance);
  } catch (error) {
    console.error('Get fraction balance error:', error);
    return '0';
  }
};

// ===========================================
// MARKETPLACE FUNCTIONS
// ===========================================

export const createListing = async (fractionTokenAddress, amount, pricePerFraction) => {
  try {
    const signer = await getSigner();
    
    // First approve marketplace to spend fractions
    const fractionToken = new ethers.Contract(
      fractionTokenAddress,
      FRACTION_TOKEN_ABI,
      signer
    );
    
    const approveTx = await fractionToken.approve(
      CONTRACTS.MARKETPLACE,
      amount
    );
    toast.info('â³ Menyetujui marketplace...');
    await approveTx.wait();
    
    // Create listing
    const marketplace = new ethers.Contract(
      CONTRACTS.MARKETPLACE,
      MARKETPLACE_ABI,
      signer
    );
    
    const tx = await marketplace.createListing(
      fractionTokenAddress,
      amount,
      ethers.parseEther(pricePerFraction.toString())
    );
    
    toast.info('â³ Membuat listing...');
    const receipt = await tx.wait();
    
    toast.success('âœ… Listing berhasil dibuat!');
    return { success: true, receipt };
  } catch (error) {
    console.error('Create listing error:', error);
    toast.error(`âŒ Gagal: ${error.reason || error.message}`);
    return { success: false, error };
  }
};

export const buyListing = async (listingId, totalCost) => {
  try {
    const signer = await getSigner();
    const marketplace = new ethers.Contract(
      CONTRACTS.MARKETPLACE,
      MARKETPLACE_ABI,
      signer
    );

    const tx = await marketplace.buyListing(listingId, {
      value: ethers.parseEther(totalCost.toString())
    });

    toast.info('â³ Membeli listing...');
    await tx.wait();
    
    toast.success('âœ… Berhasil membeli fraksi dari marketplace!');
    return { success: true };
  } catch (error) {
    console.error('Buy listing error:', error);
    toast.error(`âŒ Gagal: ${error.reason || error.message}`);
    return { success: false, error };
  }
};

export const cancelListing = async (listingId) => {
  try {
    const signer = await getSigner();
    const marketplace = new ethers.Contract(
      CONTRACTS.MARKETPLACE,
      MARKETPLACE_ABI,
      signer
    );

    const tx = await marketplace.cancelListing(listingId);

    toast.info('â³ Membatalkan listing...');
    await tx.wait();
    
    toast.success('âœ… Listing berhasil dibatalkan!');
    return { success: true };
  } catch (error) {
    console.error('Cancel listing error:', error);
    toast.error(`âŒ Gagal: ${error.reason || error.message}`);
    return { success: false, error };
  }
};

export const getListingDetails = async (listingId) => {
  try {
    const provider = getProvider();
    const marketplace = new ethers.Contract(
      CONTRACTS.MARKETPLACE,
      MARKETPLACE_ABI,
      provider
    );

    const listing = await marketplace.listings(listingId);
    
    return {
      seller: listing.seller,
      fractionToken: listing.fractionToken,
      amount: listing.amount.toString(),
      pricePerFraction: ethers.formatEther(listing.pricePerFraction),
      isActive: listing.isActive,
      createdAt: new Date(Number(listing.createdAt) * 1000)
    };
  } catch (error) {
    console.error('Get listing error:', error);
    return null;
  }
};

// ===========================================
// IPFS UPLOAD FUNCTIONS
// ===========================================

export const uploadToIPFS = async (file, pinataApiKey, pinataSecretKey) => {
  try {
    const formData = new FormData();
    formData.append('file', file);

    const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
      method: 'POST',
      headers: {
        'pinata_api_key': pinataApiKey,
        'pinata_secret_api_key': pinataSecretKey
      },
      body: formData
    });

    const data = await response.json();
    const ipfsUrl = `https://gateway.pinata.cloud/ipfs/${data.IpfsHash}`;
    
    toast.success('âœ… File berhasil diupload ke IPFS!');
    return ipfsUrl;
  } catch (error) {
    console.error('IPFS upload error:', error);
    toast.error('âŒ Gagal upload ke IPFS');
    return null;
  }
};

export const uploadJSONToIPFS = async (json, pinataApiKey, pinataSecretKey) => {
  try {
    const response = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'pinata_api_key': pinataApiKey,
        'pinata_secret_api_key': pinataSecretKey
      },
      body: JSON.stringify(json)
    });

    const data = await response.json();
    const ipfsUrl = `https://gateway.pinata.cloud/ipfs/${data.IpfsHash}`;
    
    toast.success('âœ… Metadata berhasil diupload ke IPFS!');
    return ipfsUrl;
  } catch (error) {
    console.error('IPFS JSON upload error:', error);
    toast.error('âŒ Gagal upload metadata ke IPFS');
    return null;
  }
};

// ===========================================
// HELPER FUNCTIONS
// ===========================================

export const formatAddress = (address) => {
  if (!address) return '';
  return `${address.slice(0, 6)}...${address.slice(-4)}`;
};

export const formatBNB = (amount) => {
  return `${parseFloat(amount).toFixed(4)} BNB`;
};

export const formatIDR = (amount) => {
  return new Intl.NumberFormat('id-ID', {
    style: 'currency',
    currency: 'IDR',
    minimumFractionDigits: 0
  }).format(amount);
};

export const calculateROI = (initialInvestment, currentValue) => {
  const roi = ((currentValue - initialInvestment) / initialInvestment) * 100;
  return roi.toFixed(2);
};

export const getExplorerUrl = (txHash, isTestnet = true) => {
  const baseUrl = isTestnet 
    ? 'https://testnet.bscscan.com/tx/' 
    : 'https://bscscan.com/tx/';
  return baseUrl + txHash;
};

export const waitForTransaction = async (txHash) => {
  const provider = getProvider();
  
  toast.info('â³ Menunggu konfirmasi transaksi...');
  
  try {
    const receipt = await provider.waitForTransaction(txHash);
    
    if (receipt.status === 1) {
      toast.success('âœ… Transaksi berhasil dikonfirmasi!');
      return { success: true, receipt };
    } else {
      toast.error('âŒ Transaksi gagal!');
      return { success: false, receipt };
    }
  } catch (error) {
    console.error('Transaction wait error:', error);
    toast.error('âŒ Error menunggu konfirmasi');
    return { success: false, error };
  }
};

// ===========================================
// EVENT LISTENERS
// ===========================================

export const subscribeToAssetCreated = (callback) => {
  if (typeof window.ethereum === 'undefined') return;
  
  const provider = getProvider();
  const contract = new ethers.Contract(
    CONTRACTS.ASSET_NFT,
    ASSET_NFT_ABI,
    provider
  );

  contract.on('AssetCreated', (tokenId, owner, name, totalValue, event) => {
    callback({
      tokenId: tokenId.toString(),
      owner,
      name,
      totalValue: ethers.formatEther(totalValue),
      transactionHash: event.log.transactionHash
    });
  });

  return () => contract.removeAllListeners('AssetCreated');
};

export const subscribeToFractionsPurchased = (fractionTokenAddress, callback) => {
  if (typeof window.ethereum === 'undefined') return;
  
  const provider = getProvider();
  const contract = new ethers.Contract(
    fractionTokenAddress,
    FRACTION_TOKEN_ABI,
    provider
  );

  contract.on('FractionsPurchased', (buyer, amount, cost, event) => {
    callback({
      buyer,
      amount: ethers.formatEther(amount),
      cost: ethers.formatEther(cost),
      transactionHash: event.log.transactionHash
    });
  });

  return () => contract.removeAllListeners('FractionsPurchased');
};

export const subscribeToRevenueDistributed = (fractionTokenAddress, callback) => {
  if (typeof window.ethereum === 'undefined') return;
  
  const provider = getProvider();
  const contract = new ethers.Contract(
    fractionTokenAddress,
    FRACTION_TOKEN_ABI,
    provider
  );

  contract.on('RevenueDistributed', (amount, event) => {
    callback({
      amount: ethers.formatEther(amount),
      transactionHash: event.log.transactionHash
    });
    
    toast.success(`ðŸŽ‰ Revenue baru didistribusikan: ${ethers.formatEther(amount)} BNB`);
  });

  return () => contract.removeAllListeners('RevenueDistributed');
};

// ===========================================
// CONTRACT ABIs (Simplified - Add full ABI after compilation)
// ===========================================

export const ASSET_NFT_ABI = [
  "function createAsset(string name, string description, string location, string assetType, uint256 totalValue, string imageURI, string documentURI) returns (uint256)",
  "function fractionalizeAsset(uint256 tokenId, uint256 totalFractions)",
  "function getAsset(uint256 tokenId) view returns (tuple(string name, string description, string location, string assetType, uint256 totalValue, uint256 totalFractions, address fractionTokenAddress, string imageURI, string documentURI, bool isActive, uint256 createdAt))",
  "function verifyAssetOwner(address owner, bool status)",
  "function ownerOf(uint256 tokenId) view returns (address)",
  "event AssetCreated(uint256 indexed tokenId, address indexed owner, string name, uint256 totalValue)",
  "event AssetFractionalized(uint256 indexed tokenId, address fractionToken, uint256 totalFractions)"
];

export const FRACTION_TOKEN_ABI = [
  "function buyFractions(uint256 amount) payable",
  "function sellFractions(uint256 amount)",
  "function claimRevenue()",
  "function distributeRevenue() payable",
  "function getClaimableRevenue(address holder) view returns (uint256)",
  "function balanceOf(address account) view returns (uint256)",
  "function fractionPrice() view returns (uint256)",
  "function totalRevenue() view returns (uint256)",
  "function setFractionPrice(uint256 price)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "event FractionsPurchased(address indexed buyer, uint256 amount, uint256 cost)",
  "event FractionsSold(address indexed seller, uint256 amount, uint256 payout)",
  "event RevenueDistributed(uint256 amount)",
  "event RevenueClaimed(address indexed holder, uint256 amount)"
];

export const MARKETPLACE_ABI = [
  "function createListing(address fractionToken, uint256 amount, uint256 pricePerFraction) returns (uint256)",
  "function buyListing(uint256 listingId) payable",
  "function cancelListing(uint256 listingId)",
  "function listings(uint256 listingId) view returns (tuple(address seller, address fractionToken, uint256 amount, uint256 pricePerFraction, bool isActive, uint256 createdAt))",
  "function setPlatformFee(uint256 feePercent)",
  "function withdrawFees()",
  "event ListingCreated(uint256 indexed listingId, address indexed seller, address token, uint256 amount, uint256 price)",
  "event ListingSold(uint256 indexed listingId, address indexed buyer, uint256 am
